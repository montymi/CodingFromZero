#+title: Getting Started with Code
#+subtitle: Welcome to the Rabbit Hole
#+author: Michael Montanaro
#+description: The guide I wish was around when I was getting started with coding.
#+startup: show2levels
#+date: <2023-01-31 Tue>

<!-- PROJECT SHIELDS -->
[![Contributors][contributors-shield]][contributors-url]
[![Forks][forks-shield]][forks-url]
[![Stargazers][stars-shield]][stars-url]
[![Issues][issues-shield]][issues-url]
[![MIT License][license-shield]][license-url]
[![LinkedIn][linkedin-shield]][linkedin-url]

* Level 1: Terminal
Your terminal/shell is the center for everything in programming. Below is a brief overview of what it is; however, don't get too caught up in the details.
The main goal of this level is to introduce you to some concepts and vocab, but everything that is "need to know" is found in [[#project-1][Project 1]].
It is your computer if not for the GUI (ie. apps), everything you see on your screen can be found in the terminal.
There are many "flavors" of languages used to navigate the shell, most notably: zsh, bash, fish, and shell. However, they are all fairly similar.

Any code run on your computer, in any location, is run through a terminal. This includes the IDE shells, more about that later.
Navigating through the shell to reach certain directories (folders) and edit/run files take few commands, but the terminal is extremely powerful and useful.

Advanced use of the terminal can allow for quick searches through entire directory paths.
An example of which is if you start a search at the $HOME or the base of your computer, it will search every file in your computer.
That knowledge will come with time, for now, you will focus on terminology and then a few minor commands.

** Terminology
- directory = folder
  - parent = first/main folder
  - child = folders after parent
    - (1,2,3...n)th child = how many levels deep into the parent directory the child is
      
- command line (CLI) = location to input commands to the terminal
  
- text editor = tool used to edit a file (people are *very* passionate about their editor)

- argument = something that is passed to a command to change its behavior
  
- $HOME = variable showing where the parent directory for a given user is, commonly known as the *root* directory
  - ex. my $HOME variable would be ~Users/michaelmontanaro/~
    
- $PATH = variable that shows where to find all *external* commands that might need to be run from the terminal (such as any coding language)

- $SHELL = variable that stores the current shell scripting language (as mentioned above) being used in the terminal
  
** Key Commands
If (argument) is in definition of a command, any nested text will be the possible thing to add after a space is put between the command and the argument
If (TC) is in definiction of a command, then the (argument) of the command can be filled or listed using the <TAB> key
To learn more about any of these commands type ~man~ (for manual) followed by the command or type the command followed by --help. To exit the screen that pops up, type "q".

- ~pwd~ = print working/current directory, it shows which folder you are in

- ~cd~ = change directory (argument), move to a different directory
  - /no argument/ = go back to $HOME (root) directory
  - .. = go back *one* folder
  - /folder_name/ = go up to given folder (<TAB> will show all possible folder options)

- ~mkdir~ = make a directory/folder (argument)
  - /folder_name/ = name of folder to be created, avoid spaces so use either - or _ to combine words

- ~ls~ = list contents of directory (argument)
  - ~-a~ = show hidden files (anyting starting with a ".") as well
  - ~-l~ = make everything neater and in a list
  - ~-la~ = combination of both above commands (*used most often*)

- ~vi~, ~vim~, or ~nano~ = terminal based text editors (argument) (TC)
  - /name_of_file/ = opens that file for editing if it exists, creates a new file if it does not

- ~cat~ = prints out the contents of a file (argument) (TC)
  - /name_of_file/ = file whose contents will be outputted

- ~touch~ = create a file without opening it (argument)
  - /name_of_file/ = file to be created

- ~open~ = opens a file in prefered application (argument)
  - /name_of_file/ = opens file in prefered GUI text editor or the TextEdit application
  - /url/ = opens the webpage in prefered browser

- ~echo~ = print argument to terminal (argument)
  - "text" = prints text to terminal
  - /variable/ = prints variable (such as contents of $HOME, $PATH, $SHELL) to terminal

- ~grep~ = *ADVANCED* searches a file or directory

- | = *ADVANCED* puts the output of one command into another

** Project 1
This project will introduce you to the basics of using your terminal to naviagate your computer, create files, and run CLI commands.
*** Prompt
Create a folder, named ~coding~, under the root directory, and then create a folder called ~python-testing~ in that folder.
Lastly, create a file called ~hello.py~ in the ~python-testing~ folder and then list the contents of the ~python-testing~ folder. The python file should be the 3rd child of the root directory.
**** Hint
- $HOME
  - coding
    - python-testing
      - hello.py
*** Answer
Terminal commands found in [[./project1.sh][project1.sh]]

* Level 2: Integrated Development Environments (IDEs)
To start, a text editor is exactly what it sounds like: a program/application that allows you to edit text.
Sometimes, especially when programming, the ability to edit text is not enough to create an efficient work environment.
This is where Integrated Development Environments come in, because they add some key features that are necessary in software development.
Most IDEs also allow for customizability with a plethora of plugins or editable configurations, but that will come with time.
For now, picking a simple IDE that contains the necessary features to begin your coding journey is all that you will need for this course.
** Applications
*** Visual Studio Code
(aka VS Code) My personal choice for application based IDE. The open-source code editor developed by Microsoft,
is a modern, feature-rich code editor that is suitable for a wide range of programming languages and platforms.

The main *goal* of VS Code is customizability, which allows the user to create a completely unique work environment
with a very small learning curve because of its modern, clean, and organized user interface.
**** Pros
- Wide range of extensions and plugins
- IntelliSense feature for smart code completion
- Multi-platform support (Windows, macOS, Linux)
- Multi-language support
- Built-in terminal
- Source control integration
- Debugging tools
**** Cons
- Slower than other options
- Can become fairly computer resource intensive (depending on how many plugins)
*** Sublime Text
My first ever IDE. It focuses on performance which makes it a lot faster and more lightweight than VS Code.
Similar, but less extensive, customizability options to VS Code.

The main *goal* of Sublime Text is performance coupled with a minimalist interface, removing distractions and allowing for a clean work environment.
**** Pros
- Small learning curve
- User-friendly interface
- Very little distractions
- Easily installed pacakges
- Fast performance
- UI customization
- Multi-line selection
**** Cons
- Smaller package pool
- Less built in features
- Not too commonly used anymore
*** PyCharm
Never personally used, but used by many colleagues. To put it simply, PyCharm is VS Code but optimized to function at the speed of Sublime Text.
Although this may sound ideal, it is rare that you code in one language for your entire career. This means that most PyCharm programmers have to use
language specific IDEs, slowing down work flow and rendering the customizability of PyCharm useless.

The main *goal* of PyCharm is to create a work environment specialized for writing, editing, and debugging Python code.
**** Pros
- User-friendly interface
- Intelligent code completion
- Code inspection/highlighting
- Version control integration
- Debugging tools
**** Cons
- Python specific
- Some features only available in PRO version
- Steep learning curve
- Limited customizability
- Resource intensive
** Terminal Based
*** Vim
Vim is a highly configurable text editor that is widely used by developers and system administrators.
It is known for its modal interface, which allows users to perform editing tasks efficiently with a minimal number of keystrokes.
Vim was built off of another text editor known was ~vi~, and vim has now been built upon as well, with a text editor called ~neovim~ (my personal choice).
Vi is fairly old and does not release any new features, while Vim is a very stable release with no bugs and is very slow to add features.
Neovim is always trying to implement new features but not the safest in terms of stability as the features may
have the occasional bug (although this is very rare and would not harm the computer).

- If you were to choose any flavor of vim as your IDE, I would personally send you a configuration file to fix its rather plain
  user-interface and lack of packages, since, out of box, vim is simply a text editor and must be turned into an IDE.
**** Pros
- Large community
- Customizability
- Efficient and fast
- Cross platform compatibility
- Can be turned into a full fledge IDE
- Key bindings increase productivity
**** Cons
- Steep learning curve
- Limited built-in features (out of box)
*** Nano
Nano is a simple, easy-to-use text editor that is widely used on Unix-like systems, including Linux and macOS.
This means that it should (along with vi) be installed on almost every computer/server that you might use, except Windows but everyone hates windows.
It is known for its user-friendly interface, which makes it accessible for users who are new to the command line.

- This is by FAR the easiest option, but it is also the worst option. It is very good for beginners but quickly grown out of.
**** Pros
- Small learning curve
- Cross-platform compatibility
- Built-in help
- Commands printed on screen
- Small and lightweight
**** Cons
- Limited features
- Little to no customization
- Small community
** Project 2
- Download/install any of the above options
  - If you want to use the terminal-based text editors, message me so I can get it set up for you
- Links to downloads:
  + VS Code: https://code.visualstudio.com/download
  + Sublime Text: https://www.sublimetext.com/download
  + PyCharm: https://www.jetbrains.com/pycharm/download/#section=mac
*** Prompt
- Successfully open the ~hello.py~ file nested under coding/python-testing that was created in Project 1
- Add the following to the file:
#+begin_src python :results output
print("Hello World!") # This is my first line of Python code!!!
#+end_src

#+RESULTS:
: Hello World!

- Try and run the code! Your ~hello.py~ file should resemble [[./project2.py][project2.py]]
**** Extra Credit:
  + If you used an application to write that code, try to remove the "!" using one of the terminal-based text editors.
    It is important to learn how to use the basic functionality of both.
* Level 3: Python
Python is a popular programming language that's known for its simplicity, versatility, and strong community. 
It's used for a wide range of applications, including web development, scientific computing, and data analysis.
Python's easy-to-read syntax and powerful libraries make it a great language for beginners and experienced developers alike.
** Variables
- The storage of data in easily usable words known as variables.
*** Strings, Integers, and Floats
- In python, there are three main types of variables: strings, integers, and floats.
  - *IMPORTANT* if you are to quote something in a string, you must use the opposite of the quote you are using
    to signify that it is a string. So, for example, if I am making a sentence a string I would do:
    "this is a string, Michael said". However, if I want the first part to be a quote, I must use single quotes instead.
    So it would become: "'this is a string', Michael said".
#+begin_src python :results output
  # This line (starts w/ #) is a comment, which is NOT read by the computer
  '''
  Therefore, comments can be used as notes to self or other programmers 
  in order to better understand what things do.
  This text right here a multi-line quote, set off by the three single 
  quotes and enclosed by three single quotes as well.
  Multi-line comments are also not read by the computer and very useful 
  at the beginning of programs for full project explanation if necessary.
  '''
  # a string is anything in quotes so "a", 'word', "a sentence", and '1' are all strings
  string="word"   
  
  # an integer is any whole number so -2, -1, 0, 1, 2 are all integers
  integer=1  
  
  # a float is any non-whole number, meaning 0.1, 1.1, 1.11, 11.11 are all floats
  a_float=1.2 

  print("{} is type: {}".format(string, type(string)))
  print("{} is type: {}".format(integer, type(integer)))
  print("{} is type: {}".format(a_float, type(a_float)))

  # Important example talked about above
  print("'This is a string', Michael said")

  '''
  Integers and floats can have mathmatical operations done on them such as +,-,/,*
  A coding specific one is modulus (%) which gets just the *remainder* of division
  For example, to check if a number is even, you could do num % 2 and if it returns 0 it is even
  '''
#+end_src

#+RESULTS:
: word is type: <class 'str'>
: 1 is type: <class 'int'>
: 1.2 is type: <class 'float'>
: 'This is a string', Michael said

*** Lists
- There are many ways to store the above variable types, one of which being a list.
  A list is an indexed storage system that allows you to access everything in it either via its spot in the list,
  which starts with the number zero and goes to the number of elements in the list minus one.
- Elements can very easily be added to the end of lists as well, making it a very good way to
  dynamically store and access data quickly. 
#+begin_src python :results output
a_list=[1, "2", 3.0] 
# this is a list, it can be made up of a combination of any of the variable types

print("At index {}, retrieved {} which is type: {}".format(0, a_list[0], type(a_list[0]))) 
# the [] after the list name indicates what index (spot in the list) that you want to access

print("At index {}, retrieved {} which is type: {}".format(1, a_list[1], type(a_list[1]))) 
# the index always starts at 0 so the length of the list is n-1
      
print("At index {}, retrieved {} which is type: {}\n".format(2, a_list[2], type(a_list[2])))
# the \n at the end of the string tells the computer to add another line underneath the text

# You can also use the contents of the list to find its own index, for example:
index_of_two=a_list.index("2") # .index() is used to find the index of an element on a list
print("{} is the index location for {} in the list".format(index_of_two, "2"))

# Lastly, you can append elements to the end of the list, for example:
a_list.append("added")
print("This is the list after 'added' was appended to the end of the list: ", a_list)

# You can also remove elements of the list
a_list.remove('2')
print("This is the list after '2' was removed from the list: ", a_list)

# You can also get the length of the list
# As well as every variable type in python so this next command is very helpful
length_of_list=len(a_list)
print("The length of the list after an element was added is: ", length_of_list)
#+end_src

#+RESULTS:
: At index 0, retrieved 1 which is type: <class 'int'>
: At index 1, retrieved 2 which is type: <class 'str'>
: At index 2, retrieved 3.0 which is type: <class 'float'>
: 
: 1 is the index location for 2 in the list
: This is the list after 'added' was appended to the end of the list:  [1, '2', 3.0, 'added']
: This is the list after '2' was removed from the list:  [1, 3.0, 'added']
: The length of the list after an element was added is:  3

*** Sets
- A set is very similar to that of a list, and has all the same functionality except for the fact that it cannot hold duplicates.
  Additionally, sets are unorded so you will not be able to find the index based on a specific element like in a list.
- Sets, like lists, are *mutable* meaning that you can add or remove items from it after its creation.
#+begin_src python :results output
  a_set=set([1, 2, 3, 4, 5, 1]) 
  # This line shows a list being converted to a set which is how sets are created 99.99% of the time

  print(a_set)

  # As with the list, add/append items to the end of the set or remove any element in the set
  a_set.add(6) 
  # the .add() command replaces the .append() command that is used in lists
  print("\nThis is the set after 6 was added: ", a_set)
  
  a_set.remove(1)
  print("This is the set after 1 was removed: ", a_set)
  
  length_of_set=len(a_set)
  print("The length of the set: ", length_of_set)
#+end_src

#+RESULTS:
: At index 0, retrieved 1 which is type: <class 'int'>
: At index 1, retrieved 2 which is type: <class 'str'>
: At index 2, retrieved 3.0 which is type: <class 'float'>
: 
: 1 is the index location for 2 in the list
: This is the list after 'added' was appended to the end of the list:  [1, '2', 3.0, 'added']
: This is the list after '2' was removed from the list:  [1, 3.0, 'added']
: The length of the list after an element was added is:  3

*** Tuple
- A tuple is an ordered, immutable (meaning it cannot be modified) collection of elements.
  They are useful when you want to group data together that will remain constant throughout the code.
- Tuples are not too commonly used except for very specific use cases. They are creatd by enclosing data with () instead of [] like with a list.
#+begin_src python :results output
a_tuple=("John", 32, "Male") # this creates the tuple

# each element, in order, is put into its respective variable from the tuple
name, age, gender = a_tuple
# NOTE: running print(f"some text and {some_variable}") allows variables to be passed as seen below
# However, if they are not present, an error is raised rather than printing nothing
print(f"The elements of the tuple include: {name}, {age}, {gender}")

# tuples also support indexing (similar to lists)
print("The element in the first index of the tuple is: ", a_tuple[0])
#+end_src

#+RESULTS:
: The elements of the tuple include:  John 32 Male
: The element in the first index of the tuple is:  John

*** Dictionary
- A dictionary is a collection of key-value pairs, where each key is completey unique to each other.
  They are mutable, meaning they are able to be edited in ways like adding, removing, and updating elements
  of the dictionary like just a value, just a key, or even both at once.
  They are unordered, so they cannot be accessed through indexing.
- The elements of a dictionary can be anything including integers, floats, strings, etc...
- Dictionaries are extremely common and used in most every project that I have worked on. They are a useful
  way to have a structured grouping of data that can be accessed with ease and clarity.

#+begin_src python :results output
  # Creating a dictionary
  person = {"name": "John", "age": 32, "gender": "Male"}

  # Accessing elements of a dictionary
  print("Name in dictionary: ",person.get("name"))  
  # This method of accessing the value of a key is most used and safest 
  # It will not raise an ERROR if key does not exist it will simply return NONE, example:
  print("Address in dictionary: ", person.get("address")) 
  # This will return/print a value of None because "address" is not a key in this dictionary

  print("Age in dictionary: ",person["age"])  
  # This is the other way to access the value of a key in a dictionary

  # Updating elements of a dictionary
  person["age"] = 33
  print("Updated age: ",person.get("age"))  # Output: 33

  # Adding elements to a dictionary
  person["address"] = "123 Main St" 
  # this will check if there is a key called "address" and update its value
  # if "address" does not exist, it will create it and add the value

  # Removing elements from a dictionary
  del person["age"]

  # Iterating over a dictionary, the method of ITERATING will be covered next
  # For now it is important to know that .items() will return both the key and the value
  # .keys() will return a list of just the keys
  # and .values() will return a list of just the values
  print("Each key, value pair in the dictionary after removing 'age': ")
  for key, value in person.items():
    print("\t",key, value) # the \t inserts a tab
#+end_src

#+RESULTS:
: Name in dictionary:  John
: Address in dictionary:  None
: Age in dictionary:  32
: Updated age:  33
: Each key, value pair in the dictionary: 
: 	 name John
: 	 gender Male
: 	 address 123 Main St

** For Loops and If Statements
*** For Loops
- For loops are simply a way to remove redundent/repetitive code by having it run X number of times.
  They also allow users to easily iterate through iterable objects, such as lists, sets, and dictionaries.
- The functionality of these loops can become quite advanced, with the for loops being nested within lists that
  also include if statements. However, although it is good to know that it exists, that nesting only acts in
  reducing the number of lines that a code takes. It doesn't help with speed or unlock any features that cannot be
  done with what has already been taught.
#+begin_src python :results output
    board=[[1,2,3],[4,5,6],[7,8,9]] # this is simply a a 3x3 board
    
    # this iterates through the first list (which has three elements that each is a list)
    for row in board:

      # this iterates through the second list (which has three elements)
      for num in row: 
        print(" ---",end="") 
        # formatting, the end="" just keeps python printing the next print() on the same line
      
      print()
      for num in row: # same as above for loop
	print("| {} ".format(num), end="")
      print("|")
    
    for i in range(3): # repeats below task three times
      print(" ---", end="")
#+end_src

#+RESULTS:
:  --- --- ---
: | 1 | 2 | 3 |
:  --- --- ---
: | 4 | 5 | 6 |
:  --- --- ---
: | 7 | 8 | 9 |
:  --- --- ---

*** If Statements
- If statements are ways to check variables against others or a preset value
  - They can be compared by !=, ==, <, >, <=, >= (or ~in~ if you are comparing a value to elements in a list)
    - Add ~not~ right after ~if~ to get the opposite of the comparisons
  - To link multiple comparisons in a row, the first ~if~ can be followed by ~elif~
  - To get everything that does not fit into the initial ~if~ statement, follow it with ~else~
#+begin_src python :results output
  for x in [1,2,3,4]: # Loop through a list to get each element
    if (x % 2) == 0: # check if the remainder of the element divided by 2 is 0
      print("Even Found")
    else:            # anything that is not even is odd
      print("Odd Found")

  temp=1
  if temp in [1,2,3,4]: # checks if a variable is in a list
    print("\nTemp variable found in give list")
#+end_src

#+RESULTS:
: Odd Found
: Even Found
: Odd Found
: Even Found
: 
: Temp variable found in give list

** Functions
- A function in Python is a block of reusable code that performs a specific task with inputs (parameters) and returns a value.
  Functions make code easier to write, test, and maintain by breaking up large programs into smaller pieces.
- This is the main building block of Python projects. The formatting of a function is not complex, but naming and tracking
  inputs is *key* in order to maintain organization throughout the code.
#+begin_src python :results output
# The ~def~ statement must fall BEFORE the function is called so Python knows what to call
# START OF FUNCTION
def greet(name):
"""
This function greets the person passed in as a parameter.
Description of a function usually falls immediately below the ~def~
and is enclosed in triple quotes as you can see in this example.
"""
    print("Hello, " + name + ". How are you today?")
# END OF FUNCTION

# Call the function
greet("John")
#+end_src

#+RESULTS:
: Hello, John. How are you today?

** Lambdas
- This is a bit advanced but important to note as they show up quite often.
  This is technically a subset of functions but they serve two distinct purposes,
  so I have decided to split them up entirely.
- A lambda function in Python is a single-line, anonymous function that takes inputs, performs *one* expression and returns the result.
  They are best used in the following scenarios:
  1. Map and Filter Functions: Lambda functions are often used with the map and filter functions to apply an operation to each element of a list or iterable.
  2. Sorting: Lambda functions can be used as a key function when sorting a list of items.
  3. Short Anonymous Functions: When you only need a small, throwaway function for a short period of time, a lambda function can be used to define it quickly without having to give it a name.
     
+ NOTE: it is not necessary to understand each of these examples, just knowing it exists will be helpful in the future
#+begin_src python :results output
  # Example 1: Map/Filter Functions
  
  numbers = [1, 2, 3, 4, 5]

    # Use a lambda function with map to square each number in the list
  squared_numbers = list(map(lambda x: x**2, numbers))

  print("Squared numbers:", squared_numbers)

#+end_src

#+RESULTS:
: Squared numbers: [1, 4, 9, 16, 25]

#+begin_src python :results output
  # Example 2: Sorting

  # A list of tuples representing (name, age)
  people = [("Alice", 32), ("Bob", 40), ("Charlie", 25)]

    # Sort the list by age, ascending
  sorted_people = sorted(people, key=lambda x: x[1])

  print("People sorted by age:", sorted_people)

#+end_src

#+RESULTS:
: People sorted by age: [('Charlie', 25), ('Alice', 32), ('Bob', 40)]
     
#+begin_src python :results output
  # Example 3: Short Anonymous Functions (anonymous because it technically doesn't have a name)

  sum = lambda x, y : x + y 
  # extremely short function, would've taken up much more room as a full blown function

  # Use the lambda function
  print("The sum is:", sum(10, 20))
#+end_src

#+RESULTS:
: The sum is: 30

** Project 3
- This project will introduce you to some of the structure that appears in Python projects, while
  also introducing you to all the concepts mentioned above. Each concept is key Python programming,
  and, in some way or another, makes up nearly every project that I have ever worked on.
*** Prompt
- Create a command-line game of guess that number, so when you call the python file in terminal it will prompt
  the user to guess a random integer. The "secret number" must be between a specific value (ie. 1-20) and
  must be randomly generated. If the user's guess is too high, the program should print that and continue.
  Same goes for if it is too low. If the guess is correct, congratulate the user and exit!
- Example of creating random numbers below:
#+begin_src python :results output
import random 

random_number = random.randint(1, 10) 
# Generate a random integer between 1 and 10 (inclusive)

print(f"The randomly generated number is: {random_number}") 
# Print the random number

#+end_src

#+RESULTS:
: The randomly generated number is: 5

*** Answer
Terminal:
#+begin_src shell
cd ~/coding/python-testing # change to python-testing directory
touch project3.py # create projec3.py file

# edit the file in your text editor/IDE of choice
#+end_src

Python solution found in [[./project3.py][project3.py]]

* Level 4: Git
** What is Git?
- Git is a distributed version control system that allows developers to track changes to their codebase over time.
  It was created by Linus Torvalds in 2005 as a tool to manage the development of the Linux kernel. 
  Since then, Git has become the standard tool for version control in the software development industry. 
  With Git, developers can create a repository for their codebase and track changes to their files over time.
  This allows them to revert to previous versions of their code, collaborate with other developers on the same project,
  and manage conflicts when multiple developers make changes to the same file.

- Git has since led to the creation of [[https://github.com][Github]] and [[https://gitlab.com][Gitlab]].
  Both of which are free and store anybody's projects for private or public use.
  The version controlling of git is seemlessly integrated into these companies and allows
  programmers to remotely add their work to the website.

** Remote Repositories
- In programming, a remote repository refers to a code repository that is hosted on a server
  outside of your local machine (ie. GitHub, GitLab, and Bitbucket).
  Remote repositories are typically used for collaborative development, where multiple developers
  work on the same codebase and need to share their changes with each other.

- Local repository simply refers to your own computer since the files are stored and accessed
  within your computers own memory rather than making a requst to a server. It is a great habit
  to push local projects to your choice of a remote repository.
** Installation
This installation guide will specically be for Macs. For other devices, check [[https://git-scm.com/book/en/v2/Getting-Started-Installing-Git][Git]]
  - [[https://brew.sh/][Homebrew]] is required for the following steps
     + Check if brew is on your computer: ~brew -v~
     + If command not found, run:
#+begin_src shell
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
#+end_src

1. Create GitHub or GitLab account (GitHub is my personal choice)

2. Add SSH key to your account
   + Create private/public key pair
#+begin_src shell
cd ~/.ssh
ssh-keygen -t ed25519 -C "comment"
#+end_src

     - It will prompt you for what file name to put it into, write ~personal~
     - It will also ask for a password, it is not necessary to add one
   + Copy the contents of the ~personal.pub~ file
#begin_src shell
cat ~/.ssh/personal.pub
#+end_src

   + Add to account
     - Navigate to account settings, then find /SSH Keys/ in menu on left
       + If GitHub click /Add new/
     - Paste the contents of ~personal.pub~ into the /Key/ section
     - Add anything to /Title/ section (ie. Personal Computer)
     - /Usage type/ should be default
     - If GitLab, don't set an expiration date
     - Click /Add/ and you're done, you have created your first SSH key!

3. Install git: ~brew install git~

4. Check if git was properly installed: ~git -v~

5. Edit git configuration file
   - Add the email and username to *.gitconfig*
     + Create file *~/gitconfig*
#+begin_src shell
touch ~/.gitconfig
#+end_src
     + Open file in text editor of choice then add:
#+begin_src text
[user]
    name = <github/lab username>
    email = <email used to create github/lab account>
#+end_src

6. Check to see if your email and name were added: ~git config -l~
All set!!

** Git Command
- The following are written in the order that they are most likely to be used when
  going through the basic flow of a project. Some of them are used far more often
  than others. All these commands follow the ~git~ command and a space.
  The most commonly used ones will be marked as *KEY*.
   
+ NOTE: There are many more uses for the ~git~ command but these are the key ones

1. ~clone {url, ssh}~
   - creates a directory named after the online repo along with the files
     from a GitHub or GitLab repo that is linked to the online repository
2. ~init~
   - used to initialize a repository (adds .git file to repo)
3. ~remote {add, -v, remove, ...}~
   - add origin {url}: links the files to an online GitHub or GitLab repo
     + NOTE: this connection is necessary to use all the below commands
     + NOTE: connection automatically created with ~git clone {url}~
   - -v: lists the remote connections
   - remove: connetion is terminated from the local to online repository
4. *KEY* ~add {file-name, .}~
   - <file-name>: add specific edited file name to staging
   - .: add ALL edited files to staging
5. ~status~
   - checks to see if files are in staging (green text)
6. ~branch {blank, branch-name}~
   - blank: no text after ~branch~ will list all branches plus which one
            is currently being used
   - <branch-name>: create a new branch (used for major changes to not affect <main> branch)
7. ~checkout {blank, branch-name}~
   - blank: checks to see if current branch is up to date with remote repo
   - <branch-name>: switches the branch being used
8. *KEY* ~commit -m~
   - adds the staged files to the commit history along with a message
     explaining the edits
     + the message must be enclosed by ""
9. ~log~
   - shows the commit history
10. *KEY* ~push~
    - exports the committed changes to the remote repository
11. ~merge {branch-name}~
    - combines the <main> branch with the changes from <branch-name>

** Project 4
*** Prompt
This project will take you through uploading Project 3 to a remote repository!

Out of terminal steps: (GitHub will be the assumed choice)
- Go to your GitHub page (ie. https://github.com/your_username_here)
- Click on the /Repositories/ tab then click /New/
- No template will be used
- Name the project and add a description
- Set it to private (or public)
- *Do not* add a ~README~ file from this page. It will make things very complicated.
- Leave everything else as the default and click /Create repository/
  
Terminal steps: (not as specific)
- Initialize project 3 directory
- Add connection to GitHub/Lab repository
- Create a README.md file
  + Add text to the file explaining the hardest part of Project 3 and of Project 4
- Push the changes to the remote repository on the GitHub/Lab page
- *OPTIONAL* Check your commit history in terminal
- Reload the page to see the added files!
*** Answer
Given based on GitHub solution (GitLab would have a slightly different ssh url at the ~git remote~ stage)

Terminal commands found in [[./project4.sh][project4.sh]]

* Level 5: Testing
Ensuring functionality is a key component of software development (and really any field). 
This includes making sure that the final product functions upon running as long as the system meets the requirements.
It also includes making sure any updates to the code does not change the final desired result in a way that wasn't expected.
This is done through creating tests, which are repositories, files, or even just a single function that compare the main codes
results to the desired results. It is a bit hard to understand/explain without first seeing an example. Below gives a
brief tutorial of Pytest using examples to explain how to use the module/tool and why.
** Pytest
1. Install Pytest with ~pip install pytest~
  - Pip is a tool that comes with the installation of python, allowing you to easily install python packages
2. Create a test file such as ~test_guide.py~
  - File must be in the same directory or subdirectory as the main python file
3. Add tests to the file to test the functionality of the main code
  
  File Name: ~main.py~
  #+name: main.py
  #+begin_src python :results output
  def add(x, y):
    result = x + y
    return result
  #+end_src

  File Name: ~test_main.py~
  #+name: test_main.py
  #+begin_src python :results output
  import pytest 
  from main import add # this line gives the test file access to the "add" function from main.py

  # tests the "add" function from main.py
  def test_add():
      '''
      Good habit to add comments to your code.
      Testing the add function in main.py
      Expected 2 + 3 == 5
      '''
      assert add(2,3) == 5

  '''
  the function immediately following this "decorator" (@pytest.fixture) is treated as a variable
  by pytest. it can be called just as a variable would (as seen in test_sum).
  '''
  @pytest.fixture
  def numbers():
      return [1,2,3,4,5]

  # shows how a pytest fixture can be called in a test
  def test_fixture(numbers):
      '''
      Testing using a pytest fixture as a variable
      Expected 1 + 2 + 3 + 4 + 5 == 15
      '''
      assert sum(numbers) == 15
  #+end_src
4. Lastly, run the test from the root of your project by typing ~pytest~ and hitting enter
  - Pytest will display the results of your tests in the terminal
  - To get a more verbose breakdown of the results (BETTER OPTION) type ~pytest -v~
NOTE: Pytest functions can also be added directly to the main.py file but that is not standard
** Project 5
*** Prompt
Testing was one of the last things that I learned as I began by coding journey. In fact, I didn't 
know that it existed until my first coding interview. Since then, I have spent days
working on tests. For Project 5, I want you to add pytests to each function in the [[./project5.py][project5.py]]
file found above and then have pytest successfully pass all 5 tests.
NOTE: Before beginning, make sure to fully understand the ~project5.py~ file. You can try to make changes to the code
and predict the outcome in order to practice and learn about the code.
*** Answer
Python solution found in [[./test_project5.py][test_project5.py]]
* Level 6: External Libraries
Python is one of the most popular programming languages in the world, one of the main reasons for that
is its vast ecosystem of external libraries. Each package extends pythons functionallity and has
been created by the plethora of developers that use python everyday. Below is a list of the top 10 
most commonly taught/used python libraries/packages:
1. [[https://numpy.org/][NumPy]] : numerical computing, provides powerful tools for working with arrays and matrices.
2. [[https://pandas.pydata.org/][Pandas]] : data analysis and manipulation, offers easy-to-use data structures and data analysis tools.
3. [[https://matplotlib.org/][Matplotlib]] : data visualizations, provides a wide range of plotting functions and customization options.
4. [[https://scikit-learn.org/stable/][Scikit-learn]] : machine learning, offers a broad range of tools for classification, regression, clustering, and other machine learning tasks.
5. [[https://www.tensorflow.org/][TensorFlow]] : deep learning, provides a flexible platform for building and training neural networks.
6. [[https://keras.io/][Keras]] : neural networks API, built on top of TensorFlow and makes it easy to build and train neural networks.
7. [[https://www.pygame.org/news][Pygame]] : game development, provides tools for creating games, graphics, and animations.
8. [[https://requests.readthedocs.io/en/latest/][Requests]] : making HTTP requests, makes it easy to interact with web APIs and websites.
9. [[https://beautiful-soup-4.readthedocs.io/en/latest/][Beautiful Soup]] : web scraping, provides a simple and intuitive way to extract data from HTML and XML documents.
10. [[https://www.djangoproject.com/][Django]] : web framework for building web applications, provides a powerful ORM, templating system, and administration interface.

For the sake of education, I will walk you through the process of learning ONE of these tools. This should give you
a nice process for learning any libraries in the future. 
** Pandas
Every library that you will use has *extensive* documentation, most of which will contain a section for installation and basic instructions called /Getting Started/.
The following [[https://pandas.pydata.org/docs/getting_started/index.html][link]] will take you to Pandas's introduciton guide.
This page houses the links to very specific tutorials/guides for when you get stuck using the library. To begin, navigate to their
[[https://pandas.pydata.org/docs/user_guide/10min.html#min][10 Minutes to Pandas]] tutorial and read through the walkthrough. 

As you read, take note of any major patterns that pop up in the use of the library. There is no need to try and memorize every function that comes with Pandas. 
The internet and Pandas' documentation is there for a reason and it is very easy to quickly search how to do something. 
The main difficulty in learning a new library is finding out what functionality it gives you rather than how to access that functionality.
It is a lot faster to search how to do something than trying to figure out what you need Pandas to do. This method enables the user (you)
to understand the most basic usage of Pandas, which then can be linked together to reach the more complex functionality of the library. 

*NOTE*: The code blocks are shown as they would appear when typing in the terminal based python interpretor. This can be accessed by just typing in ~python~ in 
your terminal or (the better option) donwloading iPython using ~pip install ipython~ and then just typing ~iptyhon~ in your terminal. Both methods will execute each line
of python code as you go, rather than running the whole program at once. This is standard for data analysis and is how Jupyter Notebook functions. 
** Project 6
Data science is a major reason many people get into coding in the first place. These datasets usually come in the form of a comma separated value (CSV) file, which is a way
to standardize the organization of data and allow for manipulation of the columns and rows in order to achieve a desired outcome. This is the basis of data science.
For this project, you will import and handle the data given in [[./PROJECT6.csv][PROJECT6.csv]] using the Pandas library.
*** Prompt
The dataset given is a directory of all passangers of the Titanic. I would first like you to get me the avearge age of everyone on the ship (rounded to two decimal places). 
Secondly, please return me the database but with all the missing cabin numbers dropped from the dataset. 
Lastly, please export the edited dataset (after dropping the missing cabin numbers) to a .csv file. 
This is a fairly complex problem set in comparison to the previous ones, but there are a LOT of resources online to help and you need to start getting prepared for the final project that comes after this. Good luck!
*** Answer
Answer can be found in [[./project6.py][project6.py]].
* TODO Level 7: Resume Python Project
This has definitely been the most challenging level of the guide from a creativity perspective. I struggled to find a project was complex and functional, while also being straightforward and fun.
Many of the ideas that I came up with I dropped because they were either too specific or just very overdone. I wanted to have a project that would cement a love of coding, not create a deep
loathinf of it. Nothing would be worse than to go through this entire course just to spend weeks working on the final project and then never coding again. No, my goal for this guide was to
introduce people to the world of programming and add to their intellectual curiosity. That being said, I couldn't pick just one project, so there will be two options below. One will be a data
science/visualization project and the other will be a game. Both are worthy of being placed on a resume and both are equally complex.

*NOTE*: I am not particularly familiar with any of the libraries that were used in these projects so I used the same resources and processes that you will have to use in order
to solve the problem statement. That is to say, the answers are out there. Do your research!!

** Project 7.A - Data
*** TODO Prompt
*** Answer
To avoid the temptation of you looking at my solution, I will not be making them public. Once you have completed your answer or are completely stuck, 
email me at [[mailto:mcmontanaro01@gmail.com][mcmontanaro01@gmail.com]]. I will either help guide you or send you the solution so that you may check your work.
** Project 7.B - Game
*** TODO Prompt
*** Answer
To avoid the temptation of you looking at my solution, I will not be making them public. Once you have completed your answer or are completely stuck, 
email me at [[mailto:mcmontanaro01@gmail.com][mcmontanaro01@gmail.com]]. I will either help guide you or send you the solution so that you may check your work.
* Resources
** YouTube Channels
- [[https://www.youtube.com/@definitelynoah][Definitely Noah]] : all levels of python videos, great way to continue mastering the language
- [[https://www.youtube.com/@TechWithTim][Tech with Tim]] : fantastic walk through videos of any type of project
- [[https://www.youtube.com/@NeuralNine][NeuralNine]] : introduces a lot of external libraries and shows how to use them
- [[https://www.youtube.com/@bawad][Ben Awad]] : talks specifically about being a software engineer
- [[https://www.youtube.com/@fireship][Fireship]] : very short summaries of different software that you might use in the future
- [[https://www.youtube.com/@simplilearnofficial][Simplilearn]] : full courses, very long and informative videos, great for learning anything new
- [[https://www.youtube.com/@NesoAcademy][Neso Academy]] : same as above, but shorter videos broken up into parts
- [[https://www.youtube.com/@freecodecamp][freeCodeCamp.org]] : full videos of many of the courses taugh on edX and Coursera
- [[https://www.youtube.com/@ArjanCodes][ArjanCodes]] : breaks down the fundamentals of software engineering and writing *clean* code
- [[https://www.youtube.com/@networkchuck][NetworkChuck]] : has a python course, teaches a lot about networks and ethical hacking
** Websites
- [[https://portswigger.net/web-security][PortSwigger]] : training for ethical hacking
- [[https://www.kaggle.com/][Kaggle]] : training for machine learning and data science
- [[https://karpathy.ai/zero-to-hero.html?utm_source=tldrnewsletter][Karpathy]] : blog walking through a machine learning project
- [[https://acloudguru.com/][A Cloud Guru]] : massive portfolio of differing courses, focused on cloud computing
- [[https://www.w3schools.com/][W3Schools]] : all around guide to web developmnet, including python specific web development
- [[https://www.sololearn.com/?v=2][Sololearn]] : duolingo of coding!!
- [[https://www.edx.org/][EdX]] : full courses available (such as Harvard cs50 course) for free with projects built in
- [[https://www.codecademy.com/][CodeAcademy]] : plethora of coding tutorials available for most langauges
- [[https://www.udemy.com/][Udemy]] : many smaller courses available to learn specific skills (such as game development)
- [[https://www.coursera.org/][Coursera]] : same as edX, huge list of courses available that include projects


<!-- MARKDOWN LINKS & IMAGES -->
<!-- https://www.markdownguide.org/basic-syntax/#reference-style-links -->
[contributors-shield]: https://img.shields.io/github/contributors/montymi/ClearDocs.svg?style=for-the-badge
[contributors-url]: https://github.com/montymi/ClearDocs/graphs/contributors
[forks-shield]: https://img.shields.io/github/forks/montymi/ClearDocs.svg?style=for-the-badge
[forks-url]: https://github.com/montymi/ClearDocs/network/members
[stars-shield]: https://img.shields.io/github/stars/montymi/ClearDocs.svg?style=for-the-badge
[stars-url]: https://github.com/montymi/ClearDocs/stargazers
[issues-shield]: https://img.shields.io/github/issues/montymi/ClearDocs.svg?style=for-the-badge
[issues-url]: https://github.com/montymi/ClearDocs/issues
[license-shield]: https://img.shields.io/github/license/montymi/ClearDocs.svg?style=for-the-badge
[license-url]: https://github.com/montymi/ClearDocs/blob/master/LICENSE.txt
[linkedin-shield]: https://img.shields.io/badge/-LinkedIn-black.svg?style=for-the-badge&logo=linkedin&colorB=555
[linkedin-url]: https://linkedin.com/in/michael-montanaro
